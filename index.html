<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Conteúdos</title>
</head>

<body>
    
    <main class="container">
        <div class="title">
            <h4>Conteúdos de Paradigmas de Programação:</h4>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Python</h1>
                    <p>Exemplo:</p>
                    <p>
                        print("Hello World")
                    </p>
                    <h2>Java</h2>
                    <p>Exemplo:</p>
                    <p>
                        class HelloWorld {
                        static public void main( String args[] ) {
                        System.out.println( "Hello World!" );
                        }
                        }
                    </p>
                    <h3>JavaScript</h3>
                    <p>Exemplo:</p>
                    <p>
                        const myHeading = document.querySelector("h1");
                        myHeading.textContent = "Hello World!"
                    </p>
                    <div class="flip-card-back">
                        <h1>C</h1>
                        <p>Exemplo:</p>
                        <p>
                            #include < stdio.h>

                                int main(){

                                printf("Hello World.");

                                return 0;
                                }
                        </p>
                        <h2>C++</h2>
                        <p>Exemplo:</p>
                        <p>
                            #include < iostream.h>

                                main()
                                {
                                cout << "Hello World!" << endl; return 0; } 
                            </p>
                        <h3>C#</h3>
                        <p>Exemplo:</p> 
                        <p>
                        Console.WriteLine("Hello World!");

                        </p>
                    </div>
                </div>
            </div>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Paradigma Declarativo</h1>
                    <p>Programação declarativa é quando o programador define o resultado desejado, sem especificar o
                        fluxo de controle do programa.</p>
                        <p>
                        Programação declarativa é uma abordagem poderosa para a programação de computadores. É uma boa
                        escolha para tarefas que são fáceis de definir, mas difíceis de implementar.
                    </p>
                    <div class="flip-card-back">
                        <h1>Paradigma Lógico</h1>
                        <p>Linguagens de programação lógica são baseadas na lógica matemática. O programador define um
                            conjunto de fatos, que são declarações que podem ser provadas verdadeiras. O programador
                            também define objetivos, que são declarações que o programa deve provar.</p>
                            <p>
                            A implementação da
                            linguagem tenta encontrar um conjunto de fatos e passos de inferência que, juntos, implicam
                            no objetivo.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Paradigma Imperativo</h1>
                    <p>O paradigma imperativo é uma abordagem para a programação de computadores na qual o programador
                        especifica as etapas que o programa deve seguir para atingir um resultado desejado.</p>
                        <p>
                        O paradigma imperativo é uma abordagem poderosa para a programação de computadores. Ele é
                        adequado para uma ampla gama de tarefas e é uma boa escolha para tarefas que são fáceis de
                        definir e implementar.
                    </p>
                    <div class="flip-card-back">
                        <h1>Paradigma Funcional</h1>
                        <p>O paradigma funcional é uma abordagem para a programação de computadores na qual o
                            programador declara o resultado esperado, em vez de especificar o passo a passo para
                            construção deste resultado.</p>
                            <p>
                            Essa abordagem tem duas características principais: imutabilidade e não mudança de estado
                            do software.</p>
                            <p>
                            Os programas funcionais são geralmente mais fáceis de entender e manter, e podem ser
                            eficientes em alguns casos.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Classe e Objeto</h1>
                    <p>Uma classe é um modelo abstrato que define um conjunto de objetos.</p>
                    <p>
                        A classe define as características e comportamentos que todos os objetos pertencentes a ela
                        devem ter.

                        Objetos são instâncias de classes.</p>
                        <p>
                        Quando criamos um objeto, estamos usando o modelo da classe para criar um item concreto.
                    </p>
                    <div class="flip-card-back">
                        <h1>Ábaco</h1>
                        <p>O ábaco é um instrumento de cálculo manual que foi inventado há mais de 5.500 anos na
                            Mesopotâmia.</p>
                            <p>
                            Ele é formado por uma moldura com bastões ou arames paralelos, nos quais estão os elementos
                            de contagem, que podem ser fichas, bolas ou contas.

                            Cada haste corresponde a uma posição digital, como unidades, dezenas ou centenas.</p>
                            <p>
                            Para realizar cálculos, o usuário move os elementos de contagem para cima ou para baixo,
                            dependendo da operação que deseja realizar.

                            O ábaco é um instrumento simples e eficaz, que ainda é utilizado hoje para ensinar às
                            crianças as operações de somar e subtrair.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <div class="title">
            <h5></h5>
        </div>
    </main>
    
    
    <section class="container2">
        <div class="title1">
            <h5></h5>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Alan Turing</h1>
                    <p>Alan Turing foi um matemático e criptógrafo inglês que revolucionou a computação e a
                        criptografia.</p>
                        <p>
                        Seu trabalho na Segunda Guerra Mundial ajudou a quebrar o código Enigma, o que deu aos Aliados
                        uma vantagem significativa sobre os nazistas.

                        Turing foi um pioneiro na área da inteligência artificial, e seu trabalho continua a ser
                        relevante até hoje.</p>
                        <p>
                        Ele morreu em 1954, provavelmente por suicídio.
                    </p>
                    <div class="flip-card-back">
                        <h1>Ada</h1>
                        <p>Ada Lovelace, filha de Lord Byron, foi uma matemática e escritora inglesa que escreveu o
                            primeiro algoritmo de computador da história.</p>
                            <p>
                            Ela se interessou pelo trabalho de Charles Babbage sobre a Máquina Analítica, e traduziu um
                            artigo sobre a máquina, adicionando notas que continham o algoritmo.</p>
                            <p>
                            Ada Lovelace morreu aos 36 anos de idade, mas seu trabalho é considerado fundamental para o
                            desenvolvimento da computação.
                        </p>

                    </div>
                </div>
            </div>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Arquitetura de Computadores</h1>
                    <p>A arquitetura de computadores é o conjunto de instruções que um computador é capaz de executar.</p>
                    <p>
                        Ela é importante para que os programadores possam escrever softwares que sejam compatíveis com
                        diferentes hardwares.

                        Também permite que os engenheiros possam melhorar os hardwares sem que isso provoque problemas
                        de compatibilidade.
                    </p>

                    <div class="flip-card-back">
                        <h1>Pseudocódigo</h1>
                        <p>Pseudocódigo é uma forma de representar código que é fácil para humanos entenderem.

                            Ele não é realmente executável, mas pode ser convertido em uma linguagem de programação
                            específica.</p>
                            <p>
                            Um exemplo de pseudocódigo para saudar um visitante pelo nome é:

                            // Obter o nome do visitante
                            nome = pedirNome()

                            // Exibir uma saudação
                            exibirMensagem("Olá, " + nome + "!")
                        </p>

                    </div>
                </div>
            </div>
        </div>
        <div class="title">
            <h5></h5>
        </div>
        
    </section>
    <section class="container3">
        <div class="title1">
            <h5></h5>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Complexidade de Algoritmos:
                    </h1>
                    <p> - A complexidade de algoritmos refere-se à medida do desempenho de um algoritmo em termos de recursos computacionais, como tempo e espaço.
                    </p>
                    <p> - Ajuda a entender como um algoritmo se comporta à medida que o tamanho dos dados de entrada aumenta.
                       </p>
                    <p> - A complexidade pode ser dividida em complexidade de tempo (quanto tempo o algoritmo leva para executar) e complexidade de espaço (quanta memória o algoritmo utiliza).
                    </p>
                    <p> - Pode ser expressa usando notação "Big O" para descrever o pior caso de desempenho de um algoritmo.
                    </p>

                    <div class="flip-card-back">
                        <h1>Complexidade Pessimista:</h1>
                        <p>- A complexidade pessimista de um algoritmo é a medida do seu desempenho no pior caso, ou seja, o tempo máximo ou uso de espaço que o algoritmo pode consumir.
                        </p>
                        <p> - É importante para garantir que um algoritmo funcione de forma aceitável sob todas as condições.
                        </p>
                        
                    </div>
                </div>
            </div>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1> Ordem Assintótica:
                    </h1>
                    <p>  - A ordem assintótica é uma notação usada para descrever o comportamento de uma função à medida que a entrada cresce para o infinito.
                    </p>
                    <p>- Ajuda a analisar o desempenho de algoritmos e classificá-los com base em seu crescimento relativo em relação ao tamanho da entrada.
                    </p>
                    <p>- Exemplos incluem O(1) (constante), O(log n) (logarítmica), O(n) (linear), O(n log n) (quase linear), O(n²) (quadrática), entre outros.
                    </p>
                    
                    <div class="flip-card-back">
                        <h1>Algoritmos Gulosos:
                        </h1>
                        <p> - Algoritmos gulosos são algoritmos que tomam decisões locais ótimas em cada etapa, na esperança de que isso leve a uma solução global ótima.
                        </p>
                        <p> - São usados em problemas de otimização e são eficientes, mas nem sempre garantem a solução globalmente ótima.  
                        </p>
                       
                    </div>
                </div>
            </div>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Dividir para Conquistar:
                    </h1>
                    <p> - A estratégia "dividir para conquistar" envolve a divisão de um problema em subproblemas menores, resolvendo-os separadamente e depois combinando suas soluções para obter a solução global.
                    </p>
                    <p> - É comum em algoritmos como o merge sorte o quicksort.</p>
           
                    <div class="flip-card-back">
                        <h1>Complexidade de Problemas:
                        </h1>
                        <p>- A complexidade de problemas refere-se à dificuldade intrínseca de resolver um problema específico.
                        </p>
                        <p>- Os problemas podem ser classificados em diferentes classes de complexidade, como P, NP e NP-completo.
                        </p>
                       
                    </div>
                </div>
            </div>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Classes P, NP e NP-Completo:
                    </h1>
                    <p>- A classe P contém problemas que podem ser resolvidos de forma eficiente em tempo polinomial, ou seja, em um tempo limitado pelo tamanho da entrada.
                    </p>
                    <p>  - A classe NP contém problemas para os quais, dada uma solução, pode ser verificado em tempo polinomial se a solução está correta.
                    </p>
                   
                    <div class="flip-card-back">
                        <h1>Continuação...</h1>
                        <p>  - A classe NP-completo contém problemas que são pelo menos tão difíceis quanto os mais difíceis problemas em NP. Resolver um problema NP-completo em tempo polinomial implicaria em resolver todos os problemas em NP em tempo polinomial.
                        </p>
                    
                    </div>
                </div>
            </div>
        </div>
        <div class="title">
            <h5></h5>
        </div>
    </section>
    <section class="container4">
        <div class="title1">
            <h5>Conteudos de Complexidade de Algoritmos:</h5>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1>Notação "Big O":
                    </h1>
                    <p>- A notação "Big O" descreve o limite superior do crescimento do tempo de execução ou uso de espaço de um algoritmo à medida que o tamanho dos dados de entrada aumenta.
                    </p>
                    <p>- É usada para analisar a eficiência dos algoritmos e classificá-los em termos de desempenho.
                    </p>
                    <p>- Exemplos comuns de notações "Big O" incluem O(1) (constante), O(log n) (logarítmica), O(n) (linear), O(n log n) (quase linear), O(n²) (quadrática), etc.</p>
                   
                    <div class="flip-card-back">
                        <h1>Árvore Binária:</h1>
                        <p>- Uma árvore binária é uma estrutura de dados hierárquica que consiste em nós, onde cada nó tem no máximo dois filhos, geralmente referidos como filho esquerdo e filho direito.
                        </p>
                        <p>- É amplamente utilizado em ciência da computação para representar hierarquias e organizar dados de maneira eficiente.                            
                        </p>
                        <p>- Existem vários tipos de árvores binárias, incluindo árvores binárias de busca (BST), árvores AVL (que são árvores binárias de busca balanceadas), e árvores binárias de heap (usadas em filas de prioridade).
                        </p>

                    </div>
                </div>
            </div>
        </div>
        <div class="flip-card">
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <h1> Alunos
                    </h1>
                    <p> Gabryel Tomaz de Carvalho
                    </p>
                    <p> Rafael Henrique
                    </p>
                    <p> Raphael Silva Gomes
                    </p>
                    
                    <div class="flip-card-back">
                        <h1>Referencias</h1>
                        <p>Google Bard
                        </p>
                
                    </div>
                </div>
            </div>
        </div>
        <div class="title1">
            <h5></h5>
        </div>
       
    </section>
</body>

</html>